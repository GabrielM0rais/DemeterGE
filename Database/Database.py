import sqlite3
import io
import os
from datetime import datetime

Stock_Tables = list()
Product_tables = list()
show_Columns = list()

column_list = list()
column_values = list()
columns_names_list = list()

txt_error = list()

database = ''

try:
    os.makedirs('Log de erros')
except FileExistsError:
    pass
try:
    os.makedirs('Recursos')
except FileExistsError:
    pass
try:
    os.makedirs('Database')
except FileExistsError:
    pass


try:
    txt = open('Log de erros\Log de erros Database.txt', 'r')
    txt.close()
    conf_db = open('Recursos\Conf.txt', 'r')
    conf_db.close()
except FileNotFoundError:
    txt = open('Log de erros\Log de erros Database.txt', 'a')
    txt.close()
    conf_db = open('Recursos\Conf.txt', 'a')
    conf_db.close()
    conf_db = open('Recursos\Conf.txt', 'r+')
    conf_db.write(f'date: {datetime.now().strftime("%d/%m/%Y")}\n')
    conf_db.write('database: Database\Database.db\n')
    conf_db.close()


with open('Recursos/Conf.txt', 'r') as f:
    text = f.readlines()
with open('Recursos/Conf.txt', 'r+') as f:
    for i in text:
        if 'database:' == i.split()[0]:
            database = i.split()[1]


def start_data_base(bd=database):
    global conn
    global cursor
    if 'db' in bd:
        conn = sqlite3.connect(bd)
    else:
        conn = sqlite3.connect(f'{bd}.db')
    cursor = conn.cursor()


def create_table_stock(table_name):
    try:
        sql = f"CREATE TABLE IF NOT EXISTS {table_name}(ID INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT," \
              "cod_product INT, " \
              "name_product TEXT NOT NULL," \
              "units_product INT NOT NULL," \
              "cat_product TEXT," \
              "description_product TEXT)"
        cursor.execute(sql)
    except Exception as error:
        txt_error.append(error)
        txt_ = open('Log de erros\Log de erros Database.txt', 'a')
        txt_.write(f'create_table_stock: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt_.close()


def create_table_sales(table_name):
    try:
        sql = f"CREATE TABLE IF NOT EXISTS {table_name}(name_product TEXT NOT NULL," \
              f"units_product INT NOT NULL," \
              f"buy_value INT NOT NULL, " \
              f"sale_value INT NOT NULL," \
              f"sales_today INT," \
              f"sales INT," \
              f"ID INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT)"
        cursor.execute(sql)
    except Exception as error:
        txt_error.append(error)
        txt_ = open('Log de erros\Log de erros Database.txt', 'a')
        txt_.write(f'create_table_sales: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt_.close()


def append_tables():
    """

        Read the database file started, and add the tables generated by the user in a list.

    """
    try:
        cursor.execute(f"SELECT name FROM sqlite_master WHERE TYPE = 'table'")
        for tables in cursor.fetchall():
            for table in tables:
                if table != 'sqlite_sequence':
                    cursor.execute(f'PRAGMA table_info({table})')
                    columns = [tupla for tupla in cursor.fetchall()]
                    # print(colunas[0][1])
                    if table not in Stock_Tables and columns[0][1] == 'ID':
                        Stock_Tables.append(table)
                        # print(tabela)
                    if table not in Product_tables and columns[0][1] == 'name_product':
                        Product_tables.append(table)
                        # print(tabela)
    except Exception as error:
        txt_error.append(error)
        txt_ = open('Log de erros\Log de erros Database.txt', 'a')
        txt_.write(f'append_tables: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt_.close()


def show_ST():
    """

        Use the previous function to show the tables of stock contained in the database.

    :return: Returns a list with the names of the tables of stock contained in the database.

    """
    append_tables()
    tabela = Stock_Tables
    return tabela


def show_PT():
    """

        Use the previous function to show the tables of products contained in the database.

    :return: Returns a list with the names of the tables of products contained in the database.

    """
    append_tables()
    table = Product_tables
    return table


def add_values_column_st(table_name, name_, units_, cod_, cat_, description_):
    try:
        cursor.execute(
            f'INSERT INTO {table_name} (cod_product, name_product, units_product, cat_product, description_product)'
            f' VALUES(?, ?, ?, ?, ?)', (cod_, name_, units_, cat_, description_))

    except Exception as error:
        txt_error.append(error)
        txt_ = open('Log de erros\Log de erros Database.txt', 'a')
        txt_.write(f'add_values_column_st: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt_.close()


def add_values_column_prod(table_name, name_, units_, priceB_, priceS_, today_, month_):
    try:
        cursor.execute(
            f'INSERT INTO {table_name} (name_product, units_product, buy_value, sale_value, sales_today, sales)'
            f' VALUES(?, ?, ?, ?, ?, ?)', (name_, units_, priceB_, priceS_, today_, month_))

    except Exception as error:
        txt_error.append(error)
        txt_ = open('Log de erros\Log de erros Database.txt', 'a')
        txt_.write(f'add_values_column_prod: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt_.close()


def show_values(table):
    """

        Function to add the values containing all the data and show already inserted in the columns to a list.

    :param table: Name of the column to be taken values.

    """
    try:
        sql = f"SELECT * FROM {table}"
        for row in cursor.execute(sql):
            if row not in column_values:
                # print(row)
                column_values.append(row)
    except Exception as error:
        txt_error.append(error)
        txt = open('Log de erros\Log de erros Database.txt', 'a')
        txt.write(f'show_values: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt.close()


def one_value_column(Column):
    """

        Function to add the values containing all the data and show already inserted in the columns to a list.

    :param Column: Name of the column to be taken values.
    """

    try:
        cursor.execute(f"SELECT * FROM {Column}")
        for row in cursor.fetchall():
            column_list.append(row)
    except Exception as error:
        txt_error.append(error)
        txt = open('Log de erros\Log de erros Database.txt', 'a')
        txt.write(f'one_value_column: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt.close()


def append_column_name(column, index):
    """

        Function to add to the list only the names of the products already inserted in the columns

    :param column: Column to be checked.
    :param index: Inser only the column values in the tree.
    """
    try:
        sql = f"SELECT * FROM {column}"
        for row in cursor.execute(sql):
            if row not in columns_names_list:
                columns_names_list.append(row[index])
                # print(row[2])
        set(columns_names_list)
    except Exception as error:
        txt_error.append(error)
        txt = open('Log de erros\Log de erros Database.txt', 'a')
        txt.write(f'append_column_name: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt.close()


def append_column(column):
    """

        Function to add syntax within a column to a list.

    :param column: Column to be checked.

    """
    try:
        cursor.execute(f"PRAGMA table_info({column})")
        column = [tupla[1] for tupla in cursor.fetchall()]
        for column in column:
            if column not in show_Columns:
                show_Columns.append(column)
    except Exception as error:
        txt_error.append(error)
        txt = open('Log de erros\Log de erros Database.txt', 'a')
        txt.write(f'append_column: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt.close()


def update_columns_stock(table_name, Id, cod_, units_, cat_, description_):
    try:
        cursor.execute(f"UPDATE {table_name} SET cod_product = ?, units_product = ?,"
                       f" cat_product = ?, description_product = ? WHERE Id = ?",
                       (cod_, units_, cat_, description_, Id))
    except Exception as error:
        txt_error.append(error)
        txt_ = open('Log de erros\Log de erros Database.txt', 'a')
        txt_.write(f'update_columns_stock: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt_.close()


def update_columns_prod(table_name, units_, priceB_, priceS_, today_, month_, name_):
    try:
        cursor.execute(f"UPDATE {table_name} SET units_product = ?,"
                       f" buy_value = ?, sale_value = ?, sale_value = ?, sales_today = ? WHERE name_product = ?",
                       (units_, priceB_, priceS_, today_, month_, name_))
    except Exception as error:
        txt_error.append(error)
        txt_ = open('Log de erros\Log de erros Database.txt', 'a')
        txt_.write(f'update_columns_prod: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt_.close()


def update_column_un(table_name, column_name, un):
    def calc():
        valor = int()
        try:
            cursor.execute(f"SELECT units_product-? FROM {table_name} WHERE name_product = ?", (un, column_name))
            for _ in cursor.fetchall():
                for _ in _:
                    # print(_)
                    valor = _
        except Exception as e:
            txt_error.append(e)
            txt = open('Log de erros\Log de erros Database.txt', 'a')
            txt.write(
                f'Update_column_un (Catching value): {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
            txt_error.clear()
            txt.close()
        return valor

    try:
        cursor.execute(f"UPDATE {table_name} SET units_product = ? WHERE name_product = ?", (calc(), column_name))
        cursor.execute(f'UPDATE {table_name} SET sales_today = sales_today+?, sales = sales+? WHERE name_product = ?',
                       (un, un, column_name))
    except Exception as error:
        txt_error.append(error)
        txt_ = open('Log de erros\Log de erros Database.txt', 'a')
        txt_.write(f'Update_column_un (Update value): {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt_.close()


def update_many_values(arch, value):
    try:
        archive = open(arch, 'r')
        temp = list()
        for line in archive:
            temp.append(line)
        for i in temp:
            if value in i:
                a = i.split()
                # print(f'completo: {a}')
                # print(f'valores: {a[1:]}')
                for idx, item in enumerate(a):
                    if idx != 0:
                        _ = a[idx].split('/')
                        # print(_)
                        cursor.execute(f'SELECT units_product-? FROM {_[0]} WHERE name_product = ?', (_[2], _[1]))
                        for fetchall in cursor.fetchall():
                            for un in fetchall:
                                cursor.execute(f"UPDATE {_[0]} SET units_product = ? WHERE name_product = ?", (un, _[1]))
        archive.close()
    except Exception as error:
        txt_error.append(error)
        txt = open('Log de erros\Log de erros Database.txt', 'a')
        txt.write(f'Update_many_values: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt.close()


def reset_today(table_name, name):
    try:
        cursor.execute(f'UPDATE {table_name} SET sales_today=0 WHERE name_product=?', (name, ))
    except Exception as error:
        print(error)
        txt_error.append(error)
        txt_ = open('Log de erros\Log de erros Database.txt', 'a')
        txt_.write(f'reset_today: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt_.close()


def delete_column(column, Id):
    """

        Function to delete an item in a column.

    :param column: Name of the column where the item is present.
    :param Id: Id automatically generated by the creation of the item.

    """
    try:
        sql = f"DELETE FROM {column} WHERE ID = {Id}"
        cursor.execute(sql)
    except Exception as error:
        txt_error.append(error)
        txt = open('Log de erros\Log de erros Database.txt', 'a')
        txt.write(f'delete_with_ID: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt.close()


def drop_table(name):
    """
        Drop a table chosen by the user.

    :param name: Name of the table to be Dropped.

    """
    try:
        sql = f"DROP TABLE {name}"
        cursor.execute(sql)
    except Exception as error:
        txt_error.append(error)
        txt = open('Log de erros\Log de erros Database.txt', 'a')
        txt.write(f'drop_table: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt.close()


def save_data_base():
    """

        Commits the database saving all changes made.

    """
    try:
        conn.commit()
    except Exception as error:
        txt_error.append(error)
        txt = open('Log de erros\Log de erros Database.txt', 'a')
        txt.write(f'save_data_base: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt.close()


def backup_db(path):
    """

        Generates a '.sql' file as a backup, if necessary.

    """
    try:
        with io.open(f'{path}/Backup_BancoDeDados.sql', 'w') as f:
            for linha in conn.iterdump():
                f.write(linha)
    except Exception as error:
        txt_error.append(error)
        txt = open('Log de erros\Log de erros Database.txt', 'a')
        txt.write(f'backup_db: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt.close()


def read_backup(arquivo):
    """

        Read or backup from the previous function and convert it to a '.db' file.

    :param arquivo: '.sql' file generated by the previous function.

    """
    connect = sqlite3.connect('Database/Database.db')
    try:
        f = io.open(f"{arquivo}", 'r')
        sql = f.read()
        cursor.executescript(sql)
    except Exception as error:
        txt_error.append(error)
        txt = open('Log de erros\Log de erros Database.txt', 'a')
        txt.write(f'read_backup: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt.close()

    finally:
        connect.commit()
        connect.close()


def close_db():
    try:
        conn.close()
    except Exception as error:
        txt_error.append(error)
        txt = open('Log de erros\Log de erros Database.txt', 'a')
        txt.write(f'close_db: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")} / {txt_error}\n')
        txt_error.clear()
        txt.close()
